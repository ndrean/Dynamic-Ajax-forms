<h1>Clients#index</h1>
<p>Find me in app/views/clients/index.html.erb</p>

<p>We can do:</p>

= f.input :category, :as => :select, :label => false, :collection => Choices["Categories"], include_blank: false, include_hidden: false

include_blank: false, include_hidden: false option:
Note: remove blank
before_validation :remove_empty_string
def remove_empty_string
  types.reject! { |l| l.empty? }
end
<div class="container">
    <h3>The models</h3>
    <div class="row">

        <div class="col-md-3"><div class="card"><code>
            class Client < ApplicationRecord <br>
                has_many :comments <br>
                has_many :restos, through: :comments <br>
                has_many :genres, through: :comments, source: :resto <br>
            end
        </code></div></div>

        <div class="col-md-3"><div class="card"><code>
            class Genre < ApplicationRecord <br>
                has_many :restos, -> { order(name: :asc)} <br>
                has_many :comments, through: :restos <br>
                has_many :clients, through: :comments <br>
                validates :name, uniqueness: true, presence: true <br>
                accepts_nested_attributes_for :restos <br>
            end
        </code></div></div>

        <div class="col-md-3"><div class="card"><code>
            class Resto < ApplicationRecord <br>
                belongs_to :genre, optional: true <br>
                has_many :comments, dependent: :destroy <br>
                has_many :clients, through: :comments <br>
                validates :name, uniqueness: true, presence: true <br>
                accepts_nested_attributes_for :comments <br>
            end
        </code></div></div>

        <div class="col-md-3"><div class="card"><code>
            class Comment < ApplicationRecord <br>
                belongs_to :resto, counter_cache: true, inverse_of: :comments <br>
                belongs_to :client <br>
                validates :comment, length: {minimum: 2} <br>
            end
        </code></div></div>
    </div>
    <div class="row">
        <div class="col-md-7">
            <pre>
                [Genres] 1&ltn [Restos] 1&ltn [comments] 1>n [clients]
            </pre>
            <figure>
                <%= image_tag 'db-schema.jpeg', alt: "database schema", width: '100%', height: 700  %>
            </figure>
        </div>
        <div class="col-md-5">
            <pre> <em>WHERE</em> needs <strong>table name</strong> and <em>JOINS</em> needs the <strong>association name</strong>.
            </pre>
            <p> Given a <code>client = CLIENT.find_by(name: "myfavorite")</code>, we can find his comments
            on restaurants with <code>client.restos</code>, and the genre he commented with <code>client.genres</code></p>

            <p>Conversely, given a <code>resto = RESTO.find_by('restos.name ILIKE ?', "%Sweet%")</code>, we can
            find the clients that gave a comment with: <br>
            <code>
                Resto.joins(comments: :resto).where('clients.name ILIKE ?', '%coralie%')
            </code><br>
            and give a <code>genre = Genre.find_by(name: "thai")</code>, we can find the clients gave a comment
            with: <br>
            <code>
                Genre.joins(restos: {comments: :client}).where(clients: {name: "Coralie Effertz"}).uniq
            </code><br>
            <code>
                Genre.joins(restos: {comments: :client}).merge(Client.where("clients.name= ?",  "Coralie Effertz")).uniq
            </code><br>
            <code>
                Genre.joins(restos: {comments: :client}).merge(Client.where("clients.name ILIKE ?",  "%Coralie%")).uniq
            </code><br>
            <code>
                Genre.joins(restos: {comments: :client}).where("clients.name ILIKE ?","%Coralie%").uniq
            </code><br>
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <p>On the page load <em>restos#index</em>, we defined the following <em>index</em> method 
            which displays all the restaurants on page load. We can also query for selected ones per genre.<br> 
            <code>
                &lt%= simple_form_for :search, method: 'GET' do |f| %> <br>
                &nbsp &ltdiv class="input-field"> <br>
                &nbsp &lt%= f.input_field :q, required: false, placeholder: "blank or '*' or any 'type'"  %> <br>  
                &nbsp &lt%= button_tag(type: 'submit', class: "btn btn-outline-success btn-lg", style:"padding: .8rem 1rem") do %> <br>
                    <&nbsp &nbsp &lti class="fas fa-search" id="i-search">&lt/i> <br>
                &nbsp &lt% end %> <br>
                    <&nbsp &lt/div> <br>
                &lt% end %>
            </code><br>
            <p>and the controller is:</p>
            <code> class RestosController < ApplicationController <br>
            def index <br>
            &nbsp @restos = Resto.order(name: :asc).includes([:genre]).search_by_genre(params[:search]).page(params[:page]) <br>
            end
            </code> </p>
            <p> Since we placed a params in the index method, <code>@restos</code> will be <em>nil</em> 
            on page load, so we can't use a simple scope such as: <br>
            <code>
                class Resto < ApplicationRecord <br>
                &nbsp scope :find_by_genre, ->(name) {joins(:genre).where("genres.name ILIKE ?", "%#{name}%")}
            </code>
            </p>
            <p> but need a more elaborate class method:</p>
            <p>
                <code>
                    class Resto < ApplicationRecord <br>
                    def self.search_by_genre(query) <br>
                        &nbsp # for page load where query = nil <br>
                        &nbsp if !query <br>
                        &nbsp &nbsp return Resto.all <br>
                        &nbsp end <br>
                        &nbsp # we search for an ActiveRecord array of genres and find the associated restos<br>
                        &nbsp genre = Genre.where("genres.name ILIKE ?", "%#{query[:q]}%").uniq <br>
                        &nbsp if genre <br>
            
                        &nbsp &nbsp return self.joins(:genre).merge(genre) <br>
                        &nbsp else <br>
                        &nbsp &nbsp Resto.all <br>
                        &nbsp end <br>
                    end <br>
                </code>
            </p>
        </div>
        <div class="col">
        </div>
    </div>
</div>


